:toc:
:toc-placement!:
:toclevels: 3
= LineDJ Radio Player

This module implements a player for internet radio streams.

toc::[]

== Functionality

The radio player application comes with a minimum UI that has two buttons for
starting and stopping playback, and a combo box for selecting the radio source
to be played. A status line shows some information about the currently played
radio source. If supported by the radio station, metadata about the stream is
retrieved and displayed; this typically contains information about the
currently played title and artist.

Radio sources are defined in a configuration file (see below). In the future,
there may be a graphical editor for the configuration of radio sources, but
currently all configuration has to be done manually.

What makes this application special, is the option to define under which
conditions a specific radio source should _not_ be played. Exclusion criteria
can be defined in the configuration for radio sources based on

* temporal intervals
* metadata information provided by the radio source

The radio player monitors these exclusion criteria continuously and
automatically switches to a replacement source when a match is found. When the
exclusion no longer applies, playback switches back to the original source.
That way unwanted content can be skipped, for instance artists or songs you do
not like or blocks with advertisements.

== Installation

The radio player application is an https://www.osgi.org/[OSGi] application. It
requires an OSGi framework for its execution and has to be setup accordingly.
The main link:../build.sbt[Build file] has a subproject named _radioOsgiImage_
that generates an executable OSGi image for this application. Note that you may
have to tweak the build to adapt the image to the OSGi framework of your
choice. Information how this is done and about OSGi images in general is
available in the link:../images/README.adoc[README] of the _images_ folder.

Provided that you have a working build configuration, start
https://www.scala-sbt.org/[sbt] passing it the path to your OSGi image
templates, e.g.

 sbt -mem 4096 -Dosgi.image.rootPath=/data/dev/osgi-templates

Then execute the following commands:

[source]
----
$ project radioOsgiImage
$ clean
$ osgiImage
----

This compiles the necessary projects and generates the executable OSGi image
in the folder link:../images/radio/target/image/[].

== Exclusions
There are two conceptually different ways to define exclusions for radio
sources: based on time and based on metadata. They are described in the
following subsections.

[#_time_based_exclusions]
=== Time-based Exclusions
Using this mechanism, the playback of a specific radio source can be forbidden
during specific time intervals. An interval definition can consist of a set of
week days, an hours interval, and a minutes interval. All of these elements are
optional; so intervals can be specified in a rather flexible way, as shown by
the following examples:

* On Sundays
* On working days from 8 p.m. until 12 p.m.
* Before every full hour (from 55 minutes to 60 minutes) between 6 a.m. and
  8 p.m., but not on Sundays.

This kind of exclusion is especially useful if the exclusion time can be
exactly defined. For instance, a radio station typically plays good music, but
on Sunday mornings they send a boring talk show. This time slot can then be
excluded. They are less suitable to handle more dynamic situations, such as
skipping advertisements sent every 30 minutes before the full or half hour;
in this case, there is typically a certain variance making it difficult to
find the proper intervals.

[#_metadata_based_exclusions]
=== Metadata-based Exclusions
If a radio source supports metadata, the player application fetches it
automatically and allows defining exclusions based on this information. Radio
stations send metadata between the regular blocks with audio data. A block of
metadata is a string that can consist of multiple key-value pairs in the
following format:

 key1='value1';key2='value2';...

There is a standard key named _StreamTitle_ that contains information about
what is currently played. Often, this is the only key available, but different
radio sources sometimes add further keys, for instance to mark advertisements.
Unfortunately, the content of the _StreamTitle_ field is not standardized;
radio sources use different formats to report the artist and the song title.
Typically, there is a separator character between these data elements, such as
a slash or a minus; but if the artist comes first or the song title is up to a
specific source. It is therefore not possible for the application to guess the
format. Rather, it has to be configured in form of a regular expression. Since
the order of the elements is undefined, the regular expression must contain the
two named groups `artist` and `title`, which can then be extracted by the
player application. A typical regular expression for this purpose could look as
follows:

 (?<artist>[^/]+)/\s*(?<title>.+)

This would match a _StreamTitle_ field like "Dire Straits / Brothers in arms".
The regular expression property for a radio source is optional; if it is
unspecified, the whole _StreamTitle_ field is considered as both artist and
song title, i.e. it is no longer possible to distinguish between the two.

The accuracy of the information provided in the _StreamTitle_ field varies
between different radio sources. Sometimes, the field is updated only after a
delay. It also happens frequently that other information than artist and song
title are displayed, such as the name of the radio station or the current
program, or contact information like phone numbers or mail addresses. This
makes the interpretation of this data difficult, unfortunately.

A metadata-based exclusion is basically a regular expression pattern that
matches a specific part of the metadata, the so-called _match context_. The
following match contexts are supported:

.Match contexts
[cols="1,3",options="header"]
|====
| Match context | Description
| Raw | Matches against the whole metadata string; so information in arbitrary
fields is found.
| Title | Matches against the _StreamTitle_ field; so information in both the
artist or song title is found.
| Artist | Matches against the artist. (For this to work reliably, a regular
expression defining the _StreamTitle_ format must exist.)
| Song | Matches against the song title. (For this to work reliably, a regular
expression defining the _StreamTitle_ format must exist.)
|====

When receiving a new block of metadata, the player application checks the
defined metadata exclusions against the proper match contexts. If it detects a
match, playback of this radio source is paused. After a delay, it checks
whether there is a change in metadata, so that playback is allowed again.

Due to the different usages of metadata by different radio sources, it is not
trivial to figure out when the exclusion no longer applies. For instance, an
exclusion may be defined for a specific artist. While playing a title of this
artist, the radio station may send additional metadata like the name of the
current program, which no longer contains the artist information. Nevertheless,
the radio source cannot be enabled yet; so a simple change in metadata is
obviously not sufficient. To cover such scenarios, a metadata exclusion can
specific one of the following _resume modes_:

.Resume modes
[cols="1,3",options="header"]
|====
| Resume mode | Description
| MetadataChange | The exclusion ends as soon as the metadata changes. This is
the most basic mode and also the default.
| NextSong | The exclusion ends only if different metadata is received that can
be interpreted as a new song, according to the regular expression pattern for
the _StreamTitle_ field. This mode uses the fact that other metadata often not
follows the typical format in which artist and song title information are
provided.
|====

The different _resume modes_ help solving the problem of ending an exclusion
too early; but there can also be the problem that the end of a song is not
detected with this mechanism. Consider the case that a song matching an
exclusion is played, followed by news starting at a full hour. The metadata
displayed for news does not necessarily follow the pattern of song information;
hence the resume mode `NextSong` would not apply.

To deal with this constellation, the configuration for a radio source can
specify an arbitrary number of so-called _resume intervals_. These are time
intervals, in which the radio station typically plays desired program, such as
news. A resume interval has the following effects:

* In a resume interval, a change of metadata is sufficient to end the current
  exclusion; even if the new metadata does not indicate a new song title and
  the resume mode `NextSong` is set.
* While a metadata exclusion is active, the player application checks the
  metadata in regular intervals to see whether the radio source can be enabled
  again. When scheduling the next check the beginning of the next resume
  interval is taken into account if it lies before the regular periodic check
  cycle. This means that the check is then started with the beginning of the
  resume interval, so that ideally nothing of the desired information is
  missed.

So far for the rather theoretic description of exclusions. The following
section explains how exclusions can be defined concretely. This should
hopefully make things clearer.

== Configuration
The radio player application is configured by a single XML-based configuration
file with the name `.lineDJ-radio-sources.xml` located in the current user's home
directory. When started for the first time the file is created automatically.
(The player is then inactive because it does not yet have any sources to play.)
The file has to be edited in order to define radio sources or other settings
for the application. The options can be divided into the following sections:

[#_exclusions_time_based]
=== Exclusions (time-based)
When using <<_time_based_exclusions>> it is often the case that the definition
of a time interval applies to multiple radio sources.Instead of repeating the
definition for each source, such intervals can be declared in a global section
and assigned a name.Via this name, they can then be referenced.

The fragment below shows some example declarations for the global exclusions
section:

.Named time-based exclusions
[source,xml]
----
      <exclusions>
        <exclusion name="halfHourAds">
          <days>
            <day>MONDAY</day>
            <day>TUESDAY</day>
            <day>WEDNESDAY</day>
            <day>THURSDAY</day>
            <day>FRIDAY</day>
            <day>SATURDAY</day>
          </days>
          <hours from="6" to="20"/>
          <minutes from="27" to="30"/>
        </exclusion>
        <exclusion name="fullHourAds">
          <days>
            <day>MONDAY</day>
            <day>TUESDAY</day>
            <day>WEDNESDAY</day>
            <day>THURSDAY</day>
            <day>FRIDAY</day>
            <day>SATURDAY</day>
          </days>
          <hours from="6" to="20"/>
          <minutes from="57" to="60"/>
        </exclusion>
      </exclusions>
----

The fragment shows the elements supported to define time-based intervals that
are the basis for time-based exclusions.Here two exclusion intervals are
defined, one for the time before the full hour (which is assigned the name
_fullHourAdds_) and one for the half hour (_halfHourAds_).All the parts of an
interval definition are optional.For instance, if the day of week is
irrelevant, the `days` element can be skipped; then the other defined intervals
apply for all days.Or if the `hours` element is missing, the `minutes`
interval applies for the whole day without any restrictions.This configuration
is a bit verbose, but it supports a bunch of possible scenarios.

Basically, these declarations specify that a radio source referencing these
exclusions should not be played on workdays and Saturdays between 6 o'clock in
the morning and 8 o'clock in the evening at the given minute intervals (3
minutes before a full hour and a half hour).On Sundays or before 6 a.m. or
after 8 p.m., there are no restrictions.

[#_exclusion_sets_time_based]
=== Exclusion Sets (time-based)
With the `exclusions` sections it is possible to define specific named time
intervals.To declare the exclusions of a radio source, typically multiple of
these intervals have to be combined.The source is then disabled at times that
are matched by at least one of its intervals.For radio stations sending
multiple channels, often identical exclusion intervals can be used.To reduce
duplication, it is therefore possible to define so-called _exclusion sets_ that
contain an arbitrary number of exclusion intervals.These sets have again names
that can be referenced from declarations for radio sources.Below is an example
fragment:

.Named exclusion sets
[source,xml]
----
<exclusion-sets>
  <exclusion-set name="adsOnWorkDays">
    <exclusions>
      <exclusion>
        <days>
          <day>MONDAY</day>
          <day>TUESDAY</day>
          <day>WEDNESDAY</day>
          <day>THURSDAY</day>
          <day>FRIDAY</day>
        </days>
        <hours from="6" to="20"/>
        <minutes from="25" to="30"/>
      </exclusion>
      <exclusion-ref name="fullHourAds"/>
    </exclusions>
  </exclusion-set>
</exclusion-sets>
----

This listing defines a named exclusion set consisting of two exclusion
intervals.One is defined as a reference (_fullHourAds_) and must therefore be
declared in a global _exclusions_ section.The other one (without a name) is
declared inline.Both ways are equivalent, and it is up to the user which
mechanism he or she uses to keep redundancy low.A radio source referencing
this exclusion set will be assigned both exclusion intervals.

[#_global_metadata_exclusions]
=== Global Metadata Exclusions
Another section in the configuration file defines global
<<_metadata_based_exclusions,Metadata exclusions>>. These exclusions apply to
all radio sources, so they should be quite generic. A good use case can be
exclusions for specific songs or artists, since those are typically independent
on radio stations. The following listing shows some example declarations for
metadata exclusions:

.Global metadata exclusions
[source,xml]
----
<metadataExclusions>
  <metadataExclusion name="Unwanted music">
    <pattern>.*Blunt.*</pattern>
    <matchContext>Artist</matchContext>
    <resumeMode>NextSong</resumeMode>
    <checkInterval>120</checkInterval>
  </metadataExclusion>
  <metadataExclusion>
    <pattern>.*Spots.*</pattern>
    <checkInterval>30</checkInterval>
  </metadataExclusion>
</metadataExclusions>
----

The example shows two declarations for metadata exclusions. The properties
should be familiar from the description in the <<_metadata_based_exclusions>>
section. The table below gives some further details:

.Declarations for metadata exclusions
[cols="1,3,1",options="header"]
|====
| Property | Description | Optional
| name
| The name attribute of the `metadataExclusion` element can be used to
assign a name to the exclusion. This is mainly used for the purpose of
documentation.
| Yes
| pattern
| A regular expression pattern that is matched against the current metadata
according to the `matchContext` property. Note that the expression must match
the whole area it is applied to; therefore, it makes sense to surround the
pattern with `.*` if only a contains check is required.
| No
| matchContext
| Defines the part of the metadata that is matched against the pattern.
| Yes, defaults to `Raw`
| resumeMode
| Defines the conditions when the end of the exclusion is detected.
| Yes, defaults to `MetadataChange`
| checkInterval
| A value in seconds that determines the interval in which the metadata of the
radio source is checked. During a check, metadata is received and matched
against the defined exclusions for a certain time. If a match for an exclusion
is found (which can be the original exclusion or another one), the next check
is scheduled after this delay.
| No
|====

=== Radio sources
This section defines the known radio sources. It starts with the `sources`
element under the `radio` element. Each radio source is configured in a sub
`source` element. Again, an example definition of a source is presented:

.Radio source definition
[source,xml]
----
<sources>
  <source>
    <name>HR 1</name>
    <uri>http://metafiles.gl-systemhaus.de/hr/hr1_2.m3u</uri>
    <ranking>42</ranking>
    <extension>mp3</extension>
    <exclusions>
      <exclusion>
        <days>
          <day>MONDAY</day>
          <day>TUESDAY</day>
          <day>WEDNESDAY</day>
          <day>THURSDAY</day>
          <day>FRIDAY</day>
        </days>
        <hours from="0" to="6"/>
        <minutes from="15" to="17"/>
      </exclusion>
      <exclusion-set-ref name="adsOnWorkDays"/>
    </exclusions>
    <metadata>
      <songPattern>(?&lt;artist>[^/]+)/\s*(?&lt;title>.+)</songPattern>
      <resumeIntervals>
        <resumeInterval>
          <minutes from="0" to="3" />
        </resumeInterval>
      </resumeIntervals>
      <metadataExclusions>
        <metadataExclusion>
          <pattern>.*Werbung.*</pattern>
          <matchContext>Title</matchContext>
          <resumeMode>MetadataChange</resumeMode>
          <checkInterval>60</checkInterval>
        </metadataExclusion>
      </metadataExclusions>
    </metadata>
  </source>
  ...
</sources>
----

A source is defined by a name (to be displayed to the user)
and the URL of the stream to be played. This can point to the data stream
directly or to a `m3u` file, from which the URL to the data stream has to be
extracted first. In order to determine the correct audio codec, the player
relies on file extensions. For mp3 streams, the URL should have the `mp3` file
extension. If this is not the case, this can be enforced with the `extension`
element. Optionally, a source can be assigned a _ranking_ which defines a
priority for a source. When searching for a replacement source (if an exclusion
is detected for the current source, or it has a playback error) radio sources
with a higher ranking are preferred.

With the `exclusions` element time-based exclusions can be defined for the
source. This is possible by either inlining interval declarations using the
same format as described at <<_exclusions_time_based>> (except for the name
attribute). Alternatively, exclusions or
<<_exclusion_sets_time_based, exclusion sets>> defined in the corresponding
global sections can be referenced by their names using the elements
`exclusion-ref` or `exclusion-set-ref`, respectively. Of course, defining
time-based exclusions is optional.

The same is true for the `metadata` element, which defines some properties
related to the way the radio source deals with metadata, and also metadata
exclusions specific for this source. The properties supported in this section
have already been described conceptually in the <<_metadata_based_exclusions>>
section. The table below gives some additional details:

.Metadata declaration for radio sources
[cols="1,3,1",options="header"]
|====
| Property | Description | Optional
| songPattern
| This is the regular expression used to parse the _StreamTitle_ field in the
metadata to extract the artist and the song title. As mentioned earlier, the
expression must contain the two named groups _artist_ and _title_ that the
player queries to obtain the corresponding information.
| Yes
| resumeIntervals
| Here an arbitrary number of resume intervals can be defined, i.e. known time
intervals in which the radio source typically plays desired content. Each
interval declaration is started by a `resumeInterval` element. The content of
this element can be exactly the same as for <<_time_based_exclusions>>.
| Yes
| metadataExclusions
| Under this element a number of `metadataExclusion` elements can be placed,
each of which defines a single metadata exclusion specific for this radio
source. The format is the same as presented in <<_global_metadata_exclusions>>.
| Yes
|====

=== Other configuration

In addition to the settings discussed so far, there is a number of other
options that do not fall into a specific category. They are listed in the
table below:

.Additional configuration options
[cols="1,3",options="header"]
|====
| Property | Description
| metadataMaxLen | The maximum length of a text that can be displayed directly
in the field for metadata. Longer texts are shortened and rotated.
| metadataRotateSpeed | If metadata exceeds the length configured via the
`metadataMaxLen` property, the text is rotated, so that all characters are
eventually visible. The rotation speed is based on the playback time with an
additional factor specified by this property. It basically means the number of
characters that are rotated per second. A value of `2.0` for instance means two
characters - one every 500 milliseconds. Note that rotation depends on the
update of current playback time. Here an update occurs every 100 milliseconds;
therefore, one rotation step every 100 milliseconds is also the limit for the
rotation speed.
|====
