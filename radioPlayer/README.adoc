:toc:
:toc-placement!:
:toclevels: 3
= LineDJ Radio Player

This module implements a player for internet radio streams.

toc::[]

== Functionality

The radio player application comes with a minimum UI that has two buttons for
starting and stopping playback, and a combo box for selecting the radio source
to be played. A status line shows some information about the currently played
radio source. If supported by the radio station, metadata about the stream is
retrieved and displayed; this typically contains information about the
currently played title and artist.

Radio sources are defined in a configuration file (see below). In the future,
there may be a graphical editor for the configuration of radio sources, but
currently all configuration has to be done manually.

What makes this application special, is the option to define under which
conditions a specific radio source should _not_ be played. Exclusion criteria
can be defined in the configuration for radio sources based on

* temporal intervals
* metadata information provided by the radio source

The radio player monitors these exclusion criteria continuously and
automatically switches to a replacement source when a match is found. When the
exclusion no longer applies, playback switches back to the original source.
That way unwanted content can be skipped, for instance artists or songs you do
not like or blocks with advertisements.

== Installation

The radio player application is an https://www.osgi.org/[OSGi] application. It
requires an OSGi framework for its execution and has to be setup accordingly.
The main link:../build.sbt[Build file] has a subproject named _radioOsgiImage_
that generates an executable OSGi image for this application. Note that you may
have to tweak the build to adapt the image to the OSGi framework of your
choice. Information how this is done and about OSGi images in general is
available in the link:../images/README.adoc[README] of the _images_ folder.

Provided that you have a working build configuration, start
https://www.scala-sbt.org/[sbt] passing it the path to your OSGi image
templates, e.g.

 sbt -mem 4096 -Dosgi.image.rootPath=/data/dev/osgi-templates

Then execute the following commands:

[source]
----
$ project radioOsgiImage
$ clean
$ osgiImage
----

This compiles the necessary projects and generates the executable OSGi image
in the folder link:../images/radio/target/image/[].

== Exclusions
There are two conceptually different ways to define exclusions for radio
sources: based on time and based on metadata. They are described in the
following subsections.

=== Time-based Exclusions
Using this mechanism, the playback of a specific radio source can be forbidden
during specific time intervals. An interval definition can consist of a set of
week days, an hours interval, and a minutes interval. All of these elements are
optional; so intervals can be specified in a rather flexible way, as shown by
the following examples:

* On Sundays
* On working days from 8 p.m. until 12 p.m.
* Before every full hour (from 55 minutes to 60 minutes) between 6 a.m. and
  8 p.m., but not on Sundays.

This kind of exclusion is especially useful if the exclusion time can be
exactly defined. For instance, a radio station typically plays good music, but
on Sunday mornings they send a boring talk show. This time slot can then be
excluded. They are less suitable to handle more dynamic situations, such as
skipping advertisements sent every 30 minutes before the full or half hour;
in this case, there is typically a certain variance making it difficult to
find the proper intervals.

=== Metadata-based Exclusions
If a radio source supports metadata, the player application fetches it
automatically and allows defining exclusions based on this information. Radio
stations send metadata between the regular blocks with audio data. A block of
metadata is a string that can consist of multiple key-value pairs in the
following format:

 key1='value1';key2='value2';...

There is a standard key named _StreamTitle_ that contains information about
what is currently played. Often, this is the only key available, but different
radio sources sometimes add further keys, for instance to mark advertisements.
Unfortunately, the content of the _StreamTitle_ field is not standardized;
radio sources use different formats to report the artist and the song title.
Typically, there is a separator character between these data elements, such as
a slash or a minus; but if the artist comes first or the song title is up to a
specific source. It is therefore not possible for the application to guess the
format. Rather, it has to be configured in form of a regular expression. Since
the order of the elements is undefined, the regular expression must contain the
two named groups `artist` and `title`, which can then be extracted by the
player application. A typical regular expression for this purpose could look as
follows:

 (?<artist>[^/]+)/\s*(?<title>.+)

This would match a _StreamTitle_ field like "Dire Straits / Brothers in arms".
The regular expression property for a radio source is optional; if it is
unspecified, the whole _StreamTitle_ field is considered as both artist and
song title, i.e. it is no longer possible to distinguish between the two.

The accuracy of the information provided in the _StreamTitle_ field varies
between different radio sources. Sometimes, the field is updated only after a
delay. It also happens frequently that other information than artist and song
title are displayed, such as the name of the radio station or the current
program, or contact information like phone numbers or mail addresses. This
makes the interpretation of this data difficult, unfortunately.

A metadata-based exclusion is basically a regular expression pattern that
matches a specific part of the metadata, the so-called _match context_. The
following match contexts are supported:

.Match contexts
[cols="1,3",options="header"]
|====
| Match context | Description
| Raw | Matches against the whole metadata string; so information in arbitrary
fields is found.
| Title | Matches against the _StreamTitle_ field; so information in both the
artist or song title is found.
| Artist | Matches against the artist. (For this to work reliably, a regular
expression defining the _StreamTitle_ format must exist.)
| Song | Matches against the song title. (For this to work reliably, a regular
expression defining the _StreamTitle_ format must exist.)
|====

When receiving a new block of metadata, the player application checks the
defined metadata exclusions against the proper match contexts. If it detects a
match, playback of this radio source is paused. After a delay, it checks
whether there is a change in metadata, so that playback is allowed again.

Due to the different usages of metadata by different radio sources, it is not
trivial to figure out when the exclusion no longer applies. For instance, an
exclusion may be defined for a specific artist. While playing a title of this
artist, the radio station may send additional metadata like the name of the
current program, which no longer contains the artist information. Nevertheless,
the radio source cannot be enabled yet; so a simple change in metadata is
obviously not sufficient. To cover such scenarios, a metadata exclusion can
specific one of the following _resume modes_:

.Resume modes
[cols="1,3",options="header"]
|====
| Resume mode | Description
| MetadataChange | The exclusion ends as soon as the metadata changes. This is
the most basic mode and also the default.
| NextSong | The exclusion ends only if different metadata is received that can
be interpreted as a new song, according to the regular expression pattern for
the _StreamTitle_ field. This mode uses the fact that other metadata often not
follows the typical format in which artist and song title information are
provided.
|====

The different _resume modes_ help solving the problem of ending an exclusion
too early; but there can also be the problem that the end of a song is not
detected with this mechanism. Consider the case that a song matching an
exclusion is played, followed by news starting at a full hour. The metadata
displayed for news does not necessarily follow the pattern of song information;
hence the resume mode `NextSong` would not apply.

To deal with this constellation, the configuration for a radio source can
specify an arbitrary number of so-called _resume intervals_. These are time
intervals, in which the radio station typically plays desired program, such as
news. A resume interval has the following effects:

* In a resume interval, a change of metadata is sufficient to end the current
  exclusion; even if the new metadata does not indicate a new song title and
  the resume mode `NextSong` is set.
* While a metadata exclusion is active, the player application checks the
  metadata in regular intervals to see whether the radio source can be enabled
  again. When scheduling the next check the beginning of the next resume
  interval is taken into account if it lies before the regular periodic check
  cycle. This means that the check is then started with the beginning of the
  resume interval, so that ideally nothing of the desired information is
  missed.

So far for the rather theoretic description of exclusions. The following
section explains how exclusions can be defined concretely. This should
hopefully make things clearer.

== Configuration

The radio player application is configured by a single XML-based configuration
file with the name `.lineDJ-radioplayer.xml` located in the current user's home
directory. When started for the first time the file is created automatically.
(The player is then inactive because it does not yet have any sources to play.)
The file has to be edited in order to define radio sources or other settings
for the application. An example file showing all configuration options
available can be found link:../src/test/resources[here]. The options can be
divided into the following sections:

=== Radio sources

This section defines the known radio sources. It starts with the `sources`
element under the `radio` element. Each radio source is configured in a sub
`source` element. A source is defined by a name (to be displayed to the user)
and the URL of the stream to be played. This can point to the data stream
directly or to a `m3u` file, from which the URL to the data stream has to be
extracted first. In order to determine the correct audio codec, the player
relies on file extensions. For mp3 streams, the URL should have the `mp3` file
extension. If this is not the case, this can be enforced with the `extension`
element. Optionally, a source can be assigned a _ranking_ which defines a
priority for a source. When searching for a replacement source (if the current
sources reaches an exclusion interval or has a playback error) radio sources
with a higher ranking are preferred.

With the `exclusions` element the already mentioned exclusions can be defined
for a source. Exclusion intervals can be defined in a flexible way. An interval
definition can consist of a set of week days, an hours interval, and a minutes
interval. For instance, a radio station may send commercials every half hour
between 6 a.m. and 8 p.m., but not on Sundays. The corresponding configuration
would look as follows:

[source,xml]
----
      <exclusions>
        <exclusion>
          <days>
            <day>MONDAY</day>
            <day>TUESDAY</day>
            <day>WEDNESDAY</day>
            <day>THURSDAY</day>
            <day>FRIDAY</day>
            <day>SATURDAY</day>
          </days>
          <hours from="6" to="20"/>
          <minutes from="27" to="30"/>
        </exclusion>
        <exclusion>
          <days>
            <day>MONDAY</day>
            <day>TUESDAY</day>
            <day>WEDNESDAY</day>
            <day>THURSDAY</day>
            <day>FRIDAY</day>
            <day>SATURDAY</day>
          </days>
          <hours from="6" to="20"/>
          <minutes from="57" to="60"/>
        </exclusion>
      </exclusions>
----

Here two exclusion intervals are defined, one for the time before the full
hour and one for the half hour. All the parts of an interval definition are
optional. For instance, if the day of week is irrelevant, the `days` element
can be skipped; then the other defined intervals apply for all days. Or if the
`hours` element is missing, the `minutes` interval applies for the whole day
without any restrictions. This configuration is a bit verbose, but it supports
a bunch of possible scenarios.

For a single radio source an arbitrary number of exclusion intervals can be
specified.

=== Error handling

When processing audio streams via the internet a number of errors can occur,
e.g. the network may be unavailable, a specific radio station may have a
temporary problem, or the URL of a station may be wrong (in which case the
problem is permanent). In the configuration section _error_ the behavior of the
player application in such cases can be configured. Below is an example
fragment:

[source,xml]
----
  <error>
    <retryInterval>1000</retryInterval>
    <retryIncrement>2</retryIncrement>
    <maxRetries>5</maxRetries>
    <recovery>
      <time>300</time>
      <minFailedSources>2</minFailedSources>
    </recovery>
  </error>
----

In principle, when an error of a radio source is encountered, the application
waits for a while and then tries to restart playback of this source again. If
this causes an error again, the waiting interval is increased. This is
expressed by the settings _retryInterval_, and _retryIncrement_. The former is
the minimum interval (in milliseconds) to wait for before playback is started
again. This interval is multiplied after each playback error with the value of
_retryIncrement_ which can be a floating point number greater than 1. So on
repeating errors the interval grows.

The _maxRetries_ setting defines the number of attempts to restart playback of
a radio source. When this number is exceeded the player application assumes
that there is a permanent problem with this radio source and puts it on a
list of dysfunctional sources. Then it automatically switches to the source 
with the highest ranking that is not yet on this list.

With these settings the player can handle a failing radio source well by simply
switching to another source. If there is a problem with the network, one source
after the other is tried, until the list of dysfunctional sources contains all
radio sources. In this state the player switches back to the original source 
and tries to restart playback again and again using the maximum waiting
interval.

The settings in the _recovery_ section apply after playback is successful for a
while after an error has occurred. The player then assumes that a temporary
problem is solved and tries to switch back to the original source. This
certainly makes sense after a temporary network outage: Then the player may
have switched to a replacement source, but the user's preferred source is
likely to be available again, too. It is less useful in case of a single
source failing permanently because playback will be interrupted every time a
recovery operation is attempted.

To deal with these different scenarios, the recovery behavior can be defined
with multiple settings:

* _time_ is the interval in seconds when a recovery should be attempted.
* _minFailedSources_ sets a further restriction: A recovery is only attempted
  if the list of dysfunctional sources contains at least this number of
  elements. The background is that in case of a temporary network outage
  typically multiple sources are affected, while a permanent problem of a
  specific source only causes this source to be marked as dysfunctional; in the
  latter case, a recovery does not make sense.
  
With these settings a certain flexibility in error handling can be achieved.

=== Other configuration

In addition to the settings discussed so far, there is a number of other
options that do not fall into a specific category. They are listed in the
table below:

.Additional configuration options
[cols="1,3",options="header"]
|====
| Setting | Description
| current | Stores the name of the current radio source. This is set by the
player application, so that it can play the same radio source when restarted.
| initialDelay | A delay (in milliseconds) to wait after startup before
starting playback of the first source. The reason for this property is that the
player engine relies on some audio codecs being installed in the system. As
those are started dynamically during startup of the OSGi container, it may
take some time until they are available. This setting has to be adapted to the
current machine; on fast computers, there should not be a big delay.
| metadataMaxLen | The maximum length of a text that can be displayed directly
in the field for metadata. Longer texts are shortened and rotated.
| metadataRotateSpeed | If metadata exceeds the length configured via the
`metadataMaxLen` property, the text is rotated, so that all characters are
eventually visible. The rotation speed is based on the playback time with an
additional factor specified by this property. It basically means the number of
characters that are rotated per second. A value of `2.0` for instance means two
characters - one every 500 milliseconds. Note that rotation depends on the
update of current playback time. Here an update occurs every 100 milliseconds;
therefore, one rotation step every 100 milliseconds is also the limit for the
rotation speed.
|====
