# HTTP Media Archive Startup project

With this module a number of HTTP archives (hosted by external servers) can be
integrated with the central union media archive.

## Description

This module is similar to the startup project for the local media archive. But
rather than reading media files from the local disk, all configured HTTP 
servers are contacted, and their table of content is read. The media files
managed by these servers are then added to a union archive, so that they can be
accessed in the same way as files managed by a local archive.

The union archive is again obtained from the _media facade_. Hence it can run
in the same JVM or in a remote one.

HTTP servers usually require login credentials. To represent such credentials,
the HTTP archive startup application supports so-called _realms_. Each HTTP
archive is associated with a realm; it is possible that multiple archives use
the same realm, so there is a 1:n relationship between realms and archives.

The UI of the application consists of two table controls showing the current
states of the managed HTTP archives and all realms. In order to connect to an
archive, user credentials have to be entered for the associated realm first.
This can be done by pressing the _Login_ button; as a response, a dialog is
displayed that prompts for a user name and password. On closing the login
dialog with the _Login_ button, the realm changes to the _active_ state, and
all archives assigned to this realm are started. They contact there configured
HTTP servers and change their status - depending on the results received from
the servers.

## HTTP Archives

An HTTP archive is identified by a URL pointing to a JSON file with a
content description of the archive. When starting an archive this URL is
requested first. An example content document is shown below:

```json
[
{"mediumDescriptionPath":"/test/Prince1/playlist.settings",
"metaDataPath":"/metadata/73e7151c.mdt"},
{"mediumDescriptionPath":"/test/BlindGuardian1/playlist.settings",
"metaDataPath":"/metadata/bfd036e.mdt"},
{"mediumDescriptionPath":"/test/Voices3/playlist.settings",
"metaDataPath":"/metadata/19812329.mdt"},
{"mediumDescriptionPath":"/test/U2/playlist.settings","metaDataPath":"/metadata/701992f5.mdt"}
]
```

The file is a JSON array containing an arbitrary number of objects that each
represent a medium. To define a medium, the following properties are used:

| Property | Description |
| -------- | ----------- |
| mediumDescriptionPath | A URL pointing to the XML description file of this medium. This file contains some meta data about this medium, like a name, a description, and the preferred playlist order. |
| metaDataPath | A URL pointing to a JSON file that lists all media files on this medium and their meta data. This file has the same format as meta data files generated by the local archive. |

Only entries for which both properties are defined and point to valid URLs
(which can be resolved) are accepted; all others are ignored. While meta data
files are usually generated automatically, medium description files are
created manually. Below is an example:

```xml
<?xml version='1.0' encoding='iso-8859-1'?>
<configuration>
  <name>Blind Guardian 1</name>
  <description>
    10 Albums from Blind Guardian from 1985 to 2002.
  </description>
  <order>
    <mode>Directories</mode>
  </order>
</configuration>
```

## Configuration

The configuration settings are read from the central LineDJ configuration file,
analogously as for other startup applications. The code fragment below shows an
example configuration with all supported options:

```xml
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<configuration>
<media>
  <archives>
    <archive>
      <realm>Server1</realm>
      <archiveUri>https://www.cloud-archive.org/content.json</archiveUri>
      <archiveName>My Cloud Archive</archiveName>
      <processorCount>2</processorCount>
      <processorTimeout>60</processorTimeout>
      <maxContentSize>128</maxContentSize>
      <downloadBufferSize>4194304</downloadBufferSize>
      <downloadMaxInactivity>60</downloadMaxInactivity>
      <downloadReadChunkSize>8192</downloadReadChunkSize>
      <timeoutReadSize>262144</timeoutReadSize>
      <uriMapping>
        <removePrefix>path://</removePrefix>
        <removePathComponents>1</removePathComponents>
        <uriTemplate>${medium}/${uri}</uriTemplate>
        <urlEncoding>true</urlEncoding>
        <pathSeparator>/</pathSeparator>
      </uriMapping>
    </archive>
    <archive>
      <realm>Server2</realm>
      <archiveUri>https://www.more-music.org/test/content.json</archiveUri>
      <archiveName>Another Archive</archiveName>
      <downloadBufferSize>4194304</downloadBufferSize>
      <downloadMaxInactivity>60</downloadMaxInactivity>
      <uriMapping>
        <removePrefix>path://</removePrefix>
        <uriTemplate>${medium}/${uri}</uriTemplate>
        <urlEncoding>true</urlEncoding>
        <pathSeparator>/</pathSeparator>
      </uriMapping>
    </archive>
  </archives>
  <downloadTempDir>c:\data\download\temp</downloadTempDir>
  <initTimeout>10</initTimeout>
  <stateRequestTimeout>60</stateRequestTimeout>
</media>
</configuration>
```

As can be seen, configuration information about HTTP archives is stored in an
_archives_ section which can contain an arbitrary number of _archive_ elements.
The whole configuration is put inside a _media_ section, as is the case for
the configuration of other archive types, too. So sections may overlap if a
single deployment embeds multiple archive types.

Each _archive_ element defines a single HTTP archive. There are a bunch of
settings for an archive which can be grouped into multiple categories.

### Basic meta data

The properties of this category define the basic parameters of the HTTP
archive, such as its URL or its name. The following properties are supported:

| Setting | Description | Optional |
| ------- | ----------- | -------- |
| archiveUri | The URI of the HTTP archive. This is the URL of the JSON file with the content declaration of this archive. | No |
| archiveName | A human-readable name for this archive. The name is displayed in the UI of the HTTP archive startup application. | No |
| realm | The name of the realm the archive belongs to. Realms are plain strings which are not evaluated any further. Archives assigned to the same realm share their login credentials. | No |
| processorCount | The number of processor actors to be used when reading the content of the archive during startup. This is roughly equivalent to the number of parallel HTTP requests sent to the server when processing the archive's content file. | Yes, defaults to 2. |
| processorTimeout | A timeout (in seconds) for a request for a file referenced by the archive's content document. If no response is received within this time frame, this medium is ignored. | Yes, defaults to 60 seconds. |
| maxContentSize | The maximum size (in KBytes) of a file referenced by the archive's content document. This setting has the purpose to avoid unrestricted memory allocation when processing an HTTP archive. | Yes, defaults to 64 KByte. |

### Download configuration

Downloading media files from an HTTP archive can be a bit tricky because the
consumer has full control over the download speed. One use case could be for
instance that the media file is directly played. If the user pauses playback,
the download operation can take very long and may lead to timeouts from the
HTTP server. To avoid this, the download implementation behaves as follows:

* If no data is requested for the file for a configurable time span, a block
  of data is requested by the archive itself.
* For each download operation, an in-memory buffer is kept in which data
  requested from the server is stored.
* If the in-memory buffer is full (because the client does not consume any
  data), temporary files are written.
  
The details of this algorithm can be configured using the following settings:

| Setting | Description | Optional |
| ------- | ----------- | -------- |
| downloadBufferSize | The maximum size of the in-memory buffer for the download operation (in bytes). Ideally, a file fits into this buffer completely, so that no temporary files need to be created. However, a balance need to be found between memory consumption and usage of temporary disk space. | No |
| downloadMaxInactivity | The inactivity interval (in seconds) until the download implementation requests a block of data from the server. | No |
| downloadReadChunkSize | The default chunk size (in bytes) used for download operations. | Yes, defaults to 8 KBytes |
| timeoutReadSize | The size (in bytes) to be requested from the server to avoid a timeout. This should be large enough to prevent the remote host from closing the connection. If necessary, multiple requests of the configured download chunk size will be sent until this amount of data has been loaded (or the end of the source is reached). | No |
| downloadTempDir | Defines the directory in which temporary files are created for download operations. Note that this is a global setting and not specific for a single HTTP archive. | Yes, defaults to the system temp directory. |

### URI mapping

The meta data files for the single media stored in an HTTP archive define the
URIs of the single songs. As these URIs are typically created for local media
archives, they can not necessarily be used directly to reference a file in the
HTTP archive. Therefore, a mapping has to be applied to come to the final URI
for a file to be downloaded. This is configured in a sub section named
_uriMapping_. The basic idea is that the URI for a file is derived from the
URI declared in the meta data file applying the following algorithm:

* An optional prefix is removed from the original URI. This is useful for
  instance if the URI is actually an absolute path in a local file system, and
  only a relative portion is relevant for the HTTP URI.
* An optional URL encoding can be applied. This is again useful if original
  URIs are based on file systems, so they can contain characters that are not
  valid in HTTP URIs.
* The path separator character is replaced by the slash ("/") used for URIs.
* A configurable number of path components can be removed from the beginning of
  the URI. This can be necessary if there is an overlap in the root path of a
  medium and the paths of the files belonging to this medium.
* The final URI is constructed based on a template that may contain static
  elements and variables.
  
Details are defined using the following settings:

| Setting | Description | Optional |
| ------- | ----------- | -------- |
| removePrefix | The prefix to be removed from the original URI. If the original URI does not start with this prefix, this file is ignored. | Yes, if missing, no prefix is removed. |
| removePathComponents | The number of URI path components to be removed (from the beginning). Path components are separated by the '/' character; so typically URIs are stripped at the given number of occurrences of this separator character. | Yes, defaults to 0, which means that no components are removed. | 
| urlEncoding | A boolean flag that determines whether an URL encoding is to be applied to original URIs. | Yes, defaults to *false* |
| pathSeparator | The separator character used to split path components in original URIs. This is needed if URL encoding is enabled to avoid that the path separator is encoded, too. It is typically a slash on Unix and a backslash on Windows. | Yes, if missing, path separator characters are ignored |
| uriTemplate| The template to generate the actual URI. This is an arbitrary string that can contain variables using the _${}_ notation. Supported variables are _${medium}_ for the the root path to the medium the current file belongs to, and _${uri}_ for the processed URI of the file. | Yes, defaults to _${uri}_ |

### Timeouts

When starting up an HTTP archive - when the credentials for the associated
realm have become available - some timeouts are applied:

| Setting | Description | Optional |
| ------- | ----------- | -------- |
| initTimeout | The timeout (in seconds) for requesting the actors for the central union archive. (These actors are needed to add the data about the media files hosted by the HTTP archive to the central union archive.) If the actors of the union archive cannot be obtained in this time interval, startup of the HTTP archive fails, and the union archive is considered unavailable. | Yes, defaults to 10 seconds |
| stateRequestTimeout | After an HTTP archive is started, it is queried for its state to find out whether the startup has been successful. The archive will only answer this request after it has processed the content document of the server. This property defines a timeout (in seconds) to wait for a response. If no response is received within this time, another request for the current state is sent. | Yes, defaults to 60 seconds |

### Proxy configuration

When working with HTTP archives it may be necessary to configure a proxy
server. This is supported, but not via the XML-based configuration. Rather, the
standard Java system properties that define a proxy (_http.proxyHost_ and
_http.proxyPort_) are evaluated. If both are defined, connections to the HTTP
archive are routed via this proxy server.

For more information about these properties refer to [Java Networking and
Proxies](https://docs.oracle.com/javase/8/docs/technotes/guides/net/proxies.html).
Note however, that the current implementation does not evaluate the properties 
for an HTTPS proxy; the proxy server defined by the properties for plain HTTP
is used for both HTTP and HTTPS connections.
