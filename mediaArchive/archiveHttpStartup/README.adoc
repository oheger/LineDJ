:toc:
:toc-placement!:
:toclevels: 3

= HTTP Media Archive Startup project

With this module a number of HTTP archives (hosted by external servers) can be
integrated with the central union media archive.

toc::[]

== Description

This module is similar to the startup project for the local media archive. But
rather than reading media files from the local disk, all configured HTTP 
servers are contacted, and their table of content is read. The media files
managed by these servers are then added to a union archive, so that they can be
accessed in the same way as files managed by a local archive.

The union archive is again obtained from the _media facade_. Hence it can run
in the same JVM or in a remote one.

HTTP servers usually require login credentials. To represent such credentials,
the HTTP archive startup application supports so-called _realms_. Each HTTP
archive is associated with a realm; it is possible that multiple archives use
the same realm, so there is a 1:n relationship between realms and archives.

The UI of the application consists of two table controls showing the current
states of the managed HTTP archives and all realms. In order to connect to an
archive, user credentials have to be entered for the associated realm first.
This can be done by pressing the _Login_ button; as a response, a dialog is
displayed that prompts for a user name and password. On closing the login
dialog with the _Login_ button, the realm changes to the _active_ state, and
all archives assigned to this realm are started. They contact there configured
HTTP servers and change their status - depending on the results received from
the servers.

== HTTP Archives

An HTTP archive is identified by a URL pointing to a JSON file with a
content description of the archive. When starting an archive this URL is
requested first. An example content document is shown below:

[source,json]
----
[
{"mediumDescriptionPath":"/test/Prince1/playlist.settings",
"metaDataPath":"/metadata/73e7151c.mdt"},
{"mediumDescriptionPath":"/test/BlindGuardian1/playlist.settings",
"metaDataPath":"/metadata/bfd036e.mdt"},
{"mediumDescriptionPath":"/test/Voices3/playlist.settings",
"metaDataPath":"/metadata/19812329.mdt"},
{"mediumDescriptionPath":"/test/U2/playlist.settings","metaDataPath":"/metadata/701992f5.mdt"}
]
----

The file is a JSON array containing an arbitrary number of objects that each
represent a medium. To define a medium, the following properties are used:

.Properties of a medium
[options="header"]
|=================
| Property | Description
| mediumDescriptionPath | A URL pointing to the XML description file of this
medium. This file contains some meta data about this medium, like a name, a
description, and the preferred playlist order.
| metaDataPath | A URL pointing to a JSON file that lists all media files on
this medium and their meta data. This file has the same format as meta data
files generated by the local archive.
|=================

Only entries for which both properties are defined and point to valid URLs
(which can be resolved) are accepted; all others are ignored. While meta data
files are usually generated automatically, medium description files are
created manually. Below is an example:

[source,xml]
----
<?xml version='1.0' encoding='iso-8859-1'?>
<configuration>
  <name>Blind Guardian 1</name>
  <description>
    10 Albums from Blind Guardian from 1985 to 2002.
  </description>
  <order>
    <mode>Directories</mode>
  </order>
</configuration>
----

== Protocols
The term _HTTP archive_ (obviously) indicates that media files and meta data are
located on servers that are accessed via the HTTP protocol. There are, however,
different APIs how to download specific files from the server, or how to query
the content of specific folders. Different vendors for cloud storage define
their own proprietary APIs to access the content on the server or make use of
standard protocols, such as http://webdav.org/[WebDav]. To deal with these
different access methods, HTTP archives access their data through a generic
protocol interface.

The protocol interface consists of a couple of traits in the
`de.oliver_heger.linedj.archivehttp.spi` package of the _archivehttp_ project.
Concrete implementations of these traits are found in separate OSGi modules; in
order to enable support for a specific protocol, the corresponding bundle needs
to be installed in the OSGi container.

Each protocol bundle defines a unique name. In the <<Configuration,configuration>>
of an archive, the name of the desired protocol is specified. Only archives that
reference a protocol for which a bundle is available can actually be accessed.
The sections below describe the protocol implementations that are currently
available:

=== WebDav
Files and folders on the server are accessed via the standard
http://webdav.org/[WebDav] protocol. The name of this protocol is _webdav_
(this string needs to be specified in the _protocol_ attribute in the
configuration of an archive). The URI to be used to define an archive making
use of the WebDav protocol is just the HTTP or HTTPS URI pointing to the
content definition file of this archive, e.g.

`https://webdav.magentacloud.de/test-archive/testContent.json`

This protocol is used by default if no protocol is specified in the
configuration of an archive,

=== OneDrive
This protocol allows access to data stored in a
https://onedrive.live.com/about/en-us/[Microsoft OneDrive] account. The short
protocol name is _onedrive_. Archive URIs are of the form
`<drive-id>/<relative-path>` where _drive-id_ is the ID of the OneDrive account
and _relative-path_ points to the content definition file of this archive, e.g.

`4EF53021CAED4FB7/archive/testContent.json`

== Configuration

The configuration settings are read from the central LineDJ configuration file,
analogously as for other startup applications. The code fragment below shows an
example configuration with all supported options:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<configuration>
<media>
  <realms>
    <realm>
      <name>microsoft</name>
      <type>oauth</type>
      <idp>microsoft</idp>
      <path>${sys:user.home}/.lineDJ/tokens</path>
    </realm>
  </realms>
  <archives>
    <archive>
      <realm>Server1</realm>
      <archiveUri>https://www.cloud-archive.org/content.json</archiveUri>
      <archiveName>My Cloud Archive</archiveName>
      <processorCount>2</processorCount>
      <processorTimeout>60</processorTimeout>
      <propagationBufferSize>4</propagationBufferSize>
      <maxContentSize>128</maxContentSize>
      <requestQueueSize>64</requestQueueSize>
      <downloadBufferSize>4194304</downloadBufferSize>
      <downloadMaxInactivity>60</downloadMaxInactivity>
      <downloadReadChunkSize>8192</downloadReadChunkSize>
      <timeoutReadSize>262144</timeoutReadSize>
      <uriMapping>
        <removePrefix>path://</removePrefix>
        <removePathComponents>1</removePathComponents>
        <uriTemplate>${medium}/${uri}</uriTemplate>
        <urlEncoding>true</urlEncoding>
        <pathSeparator>/</pathSeparator>
      </uriMapping>
    </archive>
    <archive>
      <realm>microsoft</realm>
      <archiveUri>4EF53021CAED4FB7/archive/testContent.json</archiveUri>
      <protocol>onedrive</protocol>
      <archiveName>Another Archive</archiveName>
      <encrypted>true</encrypted>
      <cryptUriCacheSize>2048</cryptUriCacheSize>
      <downloadBufferSize>4194304</downloadBufferSize>
      <downloadMaxInactivity>60</downloadMaxInactivity>
      <needCookies>true</needCookies>
      <uriMapping>
        <removePrefix>path://</removePrefix>
        <uriTemplate>${medium}/${uri}</uriTemplate>
        <urlEncoding>true</urlEncoding>
        <pathSeparator>/</pathSeparator>
      </uriMapping>
      <contentUriMapping>
        <removePrefix>/music/test-archive</removePrefix>
        <uriTemplate>/Musik${uri}</uriTemplate>
      </contentUriMapping>
    </archive>
  </archives>
  <downloadTempDir>c:\data\download\temp</downloadTempDir>
  <initTimeout>10</initTimeout>
  <stateRequestTimeout>60</stateRequestTimeout>
  <superPasswordFile>/data/music/archive.credentials</superPasswordFile>
</media>
</configuration>
----

As can be seen, configuration information about HTTP archives is stored in an
_archives_ section which can contain an arbitrary number of _archive_ elements.
In addition, there can be a _realms_ section defining authentication realms.
The whole configuration is put inside a _media_ section, as is the case for
the configuration of other archive types, too. So sections may overlap if a
single deployment embeds multiple archive types.

Each _archive_ element defines a single HTTP archive. There are a bunch of
settings for an archive which can be grouped into multiple categories.

=== Realms
A realm defines information how to authenticate against an HTTP archive.
Typically, a realm corresponds to a server which hosts media files. There is a
n:1 relation between archives and realms: Each archive is assigned to exactly
one realm, but multiple archives can share a single realm. This makes sense
for instance if multiple archives are hosted on the same server or if the same
credentials are used for different servers (which is not recommended).

A single realm declaration defines a name for the realm, the authentication
mechanism to be used, and additional meta data that depends on the concrete
authentication mechanism. Currently, the following mechanisms are supported:

.Supported authentication mechanisms
[cols="1,2",options="header"]
|=================
| Type | Description
| basic | The _basic auth_ mechanism. Requires a user name and password to log
into the server.
| oauth | Authentication based on https://oauth.net/2/[OAuth 2.0] (using the
https://oauth.net/2/grant-types/authorization-code/[Authorization Code Grant]).
Here an _Identity Provider_ (IDP) is contacted to obtain an _access token_ that
is used to authenticate against the server. Information about the IDP and the
tokens available is stored in a number of files in a configurable directory.
|=================

The fragment below shows the declaration of a realm of type _basic_:

[source,xml]
----
  <realms>
    <realm>
      <name>magenta</name>
      <type>basic</type>
    </realm>
  </realms>
----

The declaration consists only of the realm name (to be referenced from an
archive declaration) and the type. Such declarations are optional; if an
archive references a realm by name for which no declaration exists, an implicit
declaration of a _basic_ realm with this name is created automatically.

The declaration of a realm of type _oauth_ is more complex as it requires some
additional meta data:

[source,xml]
----
  <realms>
    <realm>
      <name>microsoft</name>
      <type>oauth</type>
      <idp>microsoft</idp>
      <path>${sys:user.home}/.lineDJ/tokens</path>
    </realm>
  </realms>
----

In addition to the default elements _name_ and _type_, a name of the IDP and a
path where the IDP-related information files are located must be specified. In
this path (note how this example makes use of system properties to reference
the user's home directory) a number of files are expected that define basic
properties of the IDP and store token information. The name of these files is
always identical to the IDP name (as defined by the _idp_ element), but they
have different extensions:

.Extensions for files defining IDPs
[cols="1,2",options="header"]
|=================
| File extension | Description
| xml | An XML file defining basic properties of the IDP, such as the endpoints
for requesting access tokens, the client ID, the scope, and the redirect URI.
An example can be found xref:idp-definition-file[below].
| sec | This file contains the client secret assigned by the IDP. As this
information is sensitive, it must be encrypted. The login into an OAuth realm
is basically the key to decrypt this file.
| toc | A file containing an access and refresh token pair. It is encrypted
with the same key as the file with the client secret. The access token to
authenticate against the IDP is read from this file; when it is expired the
refresh token is used to request another token.
|=================

[[idp-definition-file]]
A file defining basic properties of an IDP looks as follows:

[source,xml]
----
<oauth-config>
    <client-id>
      8275fe3a-2bef-45c1-b9fc-fedc940fb386
    </client-id>
    <authorization-endpoint>
      https://login.live.com/oauth20_authorize.srf
    </authorization-endpoint>
    <token-endpoint>
      https://login.live.com/oauth20_token.srf
    </token-endpoint>
    <scope>
      files.readwrite offline_access
    </scope>
    <redirect-uri>
      http://localhost:8080
    </redirect-uri>
</oauth-config>
----

=== Basic meta data

The properties of this category define the basic parameters of the HTTP
archive, such as its URL or its name. The following properties are supported:

.Basic properties of an HTTP archive
[cols="1,2,1",options="header"]
|=================
| Setting | Description | Optional
| archiveUri | The URI of the HTTP archive. The concrete structure of the URI
depends on the protocol used for the archive; details can be found in the
<<Protocols>> section. | No
| archiveName | A human-readable name for this archive. The name is displayed
in the UI of the HTTP archive startup application. | No
| protocol | References the protocol (its short name) to be used for this
archive. This determines the way the server is accessed.
| Yes, defaults to _webdav_
| realm | The name of the realm the archive belongs to. Refer to the
<<Realms>> section for further information. Archives assigned to the same
realm share their login credentials. | No
| processorCount | The number of processor actors to be used when reading the
content of the archive during startup. This is roughly equivalent to the number
of parallel HTTP requests sent to the server when processing the archive's
content file. | Yes, defaults to 2.
| processorTimeout | A timeout (in seconds) for a request for a file referenced
by the archive's content document. If no response is received within this time
frame, this medium is ignored. This timeout is also used in general for HTTP
requests, e.g. when requesting a file to be downloaded. | Yes, defaults to 60
seconds.
| propagationBufferSize | The media contained in an HTTP archive are processed
one by one to determine their content. This information then has to be propagated
to the union archive. As propagation may take longer than processing of the next
medium, the data to send to the union archive may pile up. This property defines
the number of media that can be buffered. If more processed media become
available, back-pressure is used to slow down stream processing. | Yes,
defaults to 4.
| maxContentSize | The maximum size (in KBytes) of a file referenced by the
archive's content document. This setting has the purpose to avoid unrestricted
memory allocation when processing an HTTP archive. | Yes, defaults to 64 KByte.
| requestQueueSize | All HTTP requests to an archive are added to a queue and
then executed via a connection pool. This property defines the maximum size of
this request queue. As download requests can take some time and the HTTP
connection pool is limited, requests may pile up; so the queue size should be
dimensioned appropriately. | Yes, defaults to 16.
| needCookies | A flag whether for this archive special cookie management is
required. If set to *true*, a special HTTP request actor is installed that
deals with `Set-Cookie` headers from the server. Setting this flag can be
necessary in special restricted environments, e.g. behind a corporation proxy
server. | Yes, defaults to *false*.
|=================

=== Download configuration

Downloading media files from an HTTP archive can be a bit tricky because the
consumer has full control over the download speed. One use case could be for
instance that the media file is directly played. If the user pauses playback,
the download operation can take very long and may lead to timeouts from the
HTTP server. To avoid this, the download implementation behaves as follows:

* If no data is requested for the file for a configurable time span, a block
  of data is requested by the archive itself.
* For each download operation, an in-memory buffer is kept in which data
  requested from the server is stored.
* If the in-memory buffer is full (because the client does not consume any
  data), temporary files are written.
  
The details of this algorithm can be configured using the following settings:

.Options controlling download operations
[cols="1,2,1",options="header"]
|==============================
| Setting | Description | Optional
| downloadBufferSize | The maximum size of the in-memory buffer for the
download operation (in bytes). Ideally, a file fits into this buffer
completely, so that no temporary files need to be created. However, a balance
need to be found between memory consumption and usage of temporary disk space.
| No
| downloadMaxInactivity | The inactivity interval (in seconds) until the
download implementation requests a block of data from the server. | No
| downloadReadChunkSize | The default chunk size (in bytes) used for download
operations. | Yes, defaults to 8 KBytes
| timeoutReadSize | The size (in bytes) to be requested from the server to
avoid a timeout. This should be large enough to prevent the remote host from
closing the connection. If necessary, multiple requests of the configured
download chunk size will be sent until this amount of data has been loaded (or
the end of the source is reached). | No
| downloadTempDir | Defines the directory in which temporary files are created
for download operations. Note that this is a global setting and not specific
for a single HTTP archive. | Yes, defaults to the system temp directory.
|==============================

=== URI mapping

When loading data from an HTTP archive URI references have to be resolved in
multiple ways:
* The content document of the archive refers to the medium description file and
  the meta data file for each medium contained in the archive.
* The meta data files list the (typically relative) URIs of the song files 
  belonging to this medium.

These references are typically generated for local media archives. Because of
this they cannot necessarily be used directly to reference a file in the
HTTP archive. Therefore, a mapping has to be applied to come to the final URIs
for files to be downloaded. For this purpose, a _uriMapping_ configuration is
supported. The basic idea here is that the URI for a file is derived from the
URI declared in the content document or the meta data file applying the 
following algorithm:

* An optional prefix is removed from the original URI. This is useful for
  instance if the URI is actually an absolute path in a local file system, and
  only a relative portion is relevant for the HTTP URI.
* An optional URL encoding can be applied. This is again useful if original
  URIs are based on file systems, so they can contain characters that are not
  valid in HTTP URIs.
* The path separator character is replaced by the slash ("/") used for URIs.
* A configurable number of path components can be removed from the beginning of
  the URI. This can be necessary if there is an overlap in the root path of a
  medium and the paths of the files belonging to this medium.
* The final URI is constructed based on a template that may contain static
  elements and variables.
  
Details are defined using the following settings:

.Options controlling URI mapping
[cols="1,2,1,options="header"]
|=============================
| Setting | Description | Optional
| removePrefix | The prefix to be removed from the original URI. If the
original URI does not start with this prefix, this file is ignored.
| Yes, if missing, no prefix is removed.
| removePathComponents | The number of URI path components to be removed (from
the beginning). Path components are separated by the '/' character; so
typically URIs are stripped at the given number of occurrences of this
separator character. | Yes, defaults to 0, which means that no components are
removed.
| urlEncoding | A boolean flag that determines whether an URL encoding is to be
applied to original URIs. | Yes, defaults to *false*
| pathSeparator | The separator character used to split path components in
original URIs. This is needed if URL encoding is enabled to avoid that the path
separator is encoded, too. It is typically a slash on Unix and a backslash on
Windows. | Yes, if missing, path separator characters are ignored
| uriTemplate| The template to generate the actual URI. This is an arbitrary
string that can contain variables using the _${}_ notation. Supported variables
are _${medium}_ for the the root path to the medium the current file belongs
to, and _${uri}_ for the processed URI of the file. | Yes, defaults to _${uri}_
|=============================

The configuration of an HTTP archive may contain two sections defining the
mapping of URIs: 
* The _uriMapping_ element encloses the mapping configuration for meta data
  files. It is evaluated when media files are downloaded from the archive.
* The _contentUriMapping_ element contains the mapping configuration for the
  archive's content document. It is applied when the medium description and
  meta data files are retrieved from the archive.  

=== Timeouts

When starting up an HTTP archive - when the credentials for the associated
realm have become available - some timeouts are applied:

.Options controlling timeouts
[cols="1,2,1",options="header"]
|==============================
| Setting | Description | Optional
| initTimeout | The timeout (in seconds) for requesting the actors for the
central union archive. (These actors are needed to add the data about the media
files hosted by the HTTP archive to the central union archive.) If the actors
of the union archive cannot be obtained in this time interval, startup of the
HTTP archive fails, and the union archive is considered unavailable.
| Yes, defaults to 10 seconds
| stateRequestTimeout | After an HTTP archive is started, it is queried for its
state to find out whether the startup has been successful. The archive will
only answer this request after it has processed the content document of the
server. This property defines a timeout (in seconds) to wait for a response. If
no response is received within this time, another request for the current state
is sent. | Yes, defaults to 60 seconds
|==============================

=== Encrypted archives

Archives can contain files whose names and content are encrypted using AES.
This is useful for instance if the media files are stored on a public cloud
storage. When creating the actor to manage the archive the key to decrypt the
data must be provided. URIs (specified as plain text) are then first resolved
to find the corresponding encrypted paths. The media data that is downloaded is
also decrypted, so that it can be processed in the usual way.

A few configuration options are available for encrypted archives:

.Options controlling archive encryption
[cols="1,2,1",options="header"]
|==============================
| Setting | Description | Optional
| encrypted | A boolean flag that marks an archive as encrypted. |
Yes, defaults to *false*
| cryptUriCacheSize | The resolving of URIs in an encrypted archive is an
expensive process. Therefore, parts of URIs that have already been resolved are
stored in a cache, so that they can be reused when similar URIs need to be
processed. This property defines the number of URIs that can be cached.
| Yes, defaults to 1024
|==============================

=== Super password file

In order to gain access to the music stored in the HTTP archives referenced,
the user typically has to enter a number of different credentials (to log into
the realms and to unlock encrypted archives). To make the handling of
credentials more convenient - but not necessarily less secure -, the startup
application supports storing all the credentials currently entered in a file,
which is encrypted by the so-called _super password_. There is a corresponding
action for loading this file. The user then only has to enter this super
password, and all the archives whose credentials have been saved are opened
automatically.

The location of this file with archive credentials can be configured using the
`superPasswordFile` property in the `media` section; specify the desired path
name here. If this property is missing, the path defaults to a file named
`archive.credentials` in the current user's home directory.

=== Proxy configuration

When working with HTTP archives it may be necessary to configure a proxy
server. This is supported, but not via the XML-based configuration. Rather, the
standard Java system properties that define a proxy (_http.proxyHost_ and
_http.proxyPort_) are evaluated. If both are defined, connections to the HTTP
archive are routed via this proxy server.

For more information about these properties refer to
https://docs.oracle.com/javase/8/docs/technotes/guides/net/proxies.html[Java
Networking and Proxies]. Note however, that the current implementation does not
evaluate the properties for an HTTPS proxy; the proxy server defined by the
properties for plain HTTP is used for both HTTP and HTTPS connections.
