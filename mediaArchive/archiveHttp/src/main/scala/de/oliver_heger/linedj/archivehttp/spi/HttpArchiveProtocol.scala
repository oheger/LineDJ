/*
 * Copyright 2015-2020 The Developers Team.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.oliver_heger.linedj.archivehttp.spi

import akka.actor.{ActorRef, ActorSystem}
import akka.http.scaladsl.model.{HttpRequest, Uri}
import akka.util.Timeout
import de.oliver_heger.linedj.archivehttp.http.HttpRequests

import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Success, Try}

/**
  * A trait defining an SPI to plug in different HTTP-based protocols to be
  * used for media archives.
  *
  * The purpose of this trait is to abstract over the concrete access to media
  * files. It should then be possible to host such files on various servers,
  * e.g. WebDav servers, Microsoft OneDrive, Google Drive, etc.
  *
  * As the archive management only requires a limited interaction with media
  * files (access is only read-only), the operations defined here are not too
  * complex.
  */
trait HttpArchiveProtocol {
  /**
    * Returns a name for the represented protocol. The name is used to find a
    * corresponding protocol implementation for a specific media archive.
    *
    * @return the protocol name
    */
  def name: String

  /**
    * Returns a flag whether this protocol implementation needs to access
    * multiple hosts. For instance, files could be downloaded from a different
    * server than the one that serves API calls. If this method returns
    * '''true''', an HTTP actor supporting multiple hosts is created for the
    * associated archive.
    *
    * @return a flag whether support for multi hosts is needed
    */
  def requiresMultiHostSupport: Boolean

  /**
    * Generates the URI to be used for the HTTP archive configuration from the
    * original URI read from configuration file. Concrete protocol
    * implementations can use this method to transform or enrich the URI
    * provided by the user, e.g. to add a default host. The resulting URI is
    * used as a basis for the URIs generated by the archive components; those
    * can then again be passed to other methods of this trait. As constructing
    * the URI can fail - if the source URI is invalid -, result is a ''Try''.
    * This base implementation returns a ''Success'' with the given URI without
    * any changes.
    *
    * @param sourceUri the source URI from the configuration file
    * @return a ''Try'' with the base URI to be used for the archive
    */
  def generateArchiveUri(sourceUri: String): Try[Uri] = Success(Uri(sourceUri))

  /**
    * Handles a request to download a specific media file. The passed in HTTP
    * actor can be used to send the request. This base implementation sends a
    * direct GET request for the given URI. If a concrete protocol requires
    * some extra steps (e.g. obtaining the download URI first), these have to
    * be implemented here. In order to actually download the file, the entity
    * in the response is processed.
    *
    * @param httpActor the HTTP request actor for sending requests
    * @param uri       the URI pointing to the media file
    * @param ec        the execution context
    * @param system           the actor system to materialize streams
    * @param timeout   a timeout for sending the request
    * @return a ''Future'' with the response of the download request
    */
  def downloadMediaFile(httpActor: ActorRef, uri: Uri)
                       (implicit ec: ExecutionContext, system: ActorSystem, timeout: Timeout):
  Future[HttpRequests.ResponseData] = {
    val request = HttpRequest(uri = uri)
    HttpRequests.sendRequest(httpActor, HttpRequests.SendRequest(request, null))
  }

  /**
    * Returns a [[UriResolverController]] to handle a resolve operation for the
    * URI specified. The resolve operation is then processed with the help of
    * this controller.
    *
    * @param requestUri the request URI that needs to be resolved
    * @param basePath   the base path of the archive derived from the URI
    *                   generated by ''generateArchiveUri()''
    * @return the controller for the resolve operation
    */
  def resolveController(requestUri: Uri, basePath: String): UriResolverController
}
