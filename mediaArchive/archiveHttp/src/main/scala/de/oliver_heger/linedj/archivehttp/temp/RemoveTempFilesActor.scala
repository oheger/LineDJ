/*
 * Copyright 2015-2025 The Developers Team.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.oliver_heger.linedj.archivehttp.temp

import com.github.cloudfiles.core.Model
import com.github.cloudfiles.core.utils.Walk
import de.oliver_heger.linedj.io.{LocalFsUtils, RemoveFileActor}
import de.oliver_heger.linedj.utils.ChildActorFactory
import org.apache.pekko.actor.typed.scaladsl.adapter.*
import org.apache.pekko.actor.{Actor, ActorLogging, ActorRef, Props, typed}
import org.apache.pekko.stream.scaladsl.Sink

import java.nio.file.Path
import scala.concurrent.Future

object RemoveTempFilesActor:

  /**
    * A message processed by [[RemoveTempFilesActor]] that causes the
    * specified files to be removed. All paths are passed to the managed
    * remove file actor. No response is sent.
    *
    * @param files the files to be removed
    */
  case class RemoveTempFiles(files: Iterable[Path])

  /**
    * A message processed by [[RemoveTempFilesActor]] that triggers a clean up
    * of the temporary directory for download files. All files and directories
    * created by older runs of the HTTP archive component are passed to the
    * remove file child actor.
    *
    * @param root      the root of the directory to be scanned
    * @param generator the generator for temp file names
    */
  case class ClearTempDirectory(root: Path, generator: TempPathGenerator)

  private class RemoteTempFilesActorImpl(dispatcher: String)
    extends RemoveTempFilesActor(dispatcher) with ChildActorFactory

  /**
    * Creates a ''Props'' object for the creation of a new actor instance.
    *
    * @param blockingDispatcherName the name of the blocking dispatcher
    * @return ''Props'' to create a new actor instance
    */
  def apply(blockingDispatcherName: String): Props =
    Props(classOf[RemoteTempFilesActorImpl], blockingDispatcherName)

  /**
    * A transformation function for the directory stream source. When
    * processing the temporary download directory in a first step all files
    * can be removed. Only then it is possible to remove directories. So,
    * depending on the step, either files or directories are mapped to
    * ''None'' values.
    *
    * @param dirFlag the directory flag to check for
    * @param p       the path to be mapped
    * @param isDir   a flag whether this path is a directory
    * @return the transformed stream element
    */
  private def transformByPathType(dirFlag: Boolean)(p: Path, isDir: Boolean): Option[Path] =
    if isDir == dirFlag then Some(p)
    else None

/**
  * An actor class that allows removing of temporary download files.
  *
  * During a download operation, it may be necessary to create temporary files
  * for media content read from the server. After the download operation
  * terminates, these files have to be removed again.
  *
  * Removing temporary files is a fire-and-forget operation; if a file cannot
  * be removed for whatever reason, no other parts of the HTTP archive should
  * be affected or crash. Therefore, no responses for remove operations are
  * expected. This actor class creates a child actor of type
  * [[de.oliver_heger.linedj.io.RemoveFileActor]] and delegates remove
  * operations to it. If an operation fails, the child actor crashes and is
  * then automatically restarted.
  *
  * To deal with remaining temporary files (which could not be removed in a
  * first attempt or whose responsible download actors crashed before they
  * could trigger a remove operation), there is functionality to scan the
  * root directory for temporary files and collect all temporary files
  * generated by older runs of the HTTP archive; they can then be deleted.
  * This functionality could be invoked for instance on startup of the
  * archive application.
  *
  * @param blockingDispatcherName the name of the dispatcher to be used for
  *                               the remove child actor
  */
class RemoveTempFilesActor(blockingDispatcherName: String) extends Actor with ActorLogging:
  this: ChildActorFactory =>

  import RemoveTempFilesActor.*
  import context.dispatcher

  /** The actor which actually removes files. */
  private var removeFileActor: ActorRef = _

  override def preStart(): Unit =
    removeFileActor = createChildActor(Props[RemoveFileActor]()
      .withDispatcher(blockingDispatcherName))

  override def receive: Receive =
    case RemoveTempFiles(files) =>
      files map RemoveFileActor.RemoveFile.apply foreach removeFileActor.!

    case RemoveFileActor.FileRemoved(path) =>
      log.debug("Removed temporary file {}.", path)

    case ClearTempDirectory(root, generator) =>
      deleteTempFilesAndCollectFolders(root, generator) foreach { folders =>
        folders.foreach(deleteElement)
      }

  /**
    * Scans the specified root directory for temporary download files and
    * removes all encountered files directly. The folders are aggregated and
    * returned, so that they can be safely deleted after all files have been
    * removed. To make this possible, they are returned in an order where
    * subfolders come first.
    *
    * @param root      the root directory
    * @param generator the path generator
    * @return a [[Future]] with a list of temporary folders to delete
    */
  private def deleteTempFilesAndCollectFolders(root: Path, generator: TempPathGenerator):
  Future[List[Model.Folder[Path]]] =
    val localFs = LocalFsUtils.createLocalFs(root, blockingDispatcherName, context.system)
    val walkOptions = Walk.WalkConfig(
      fileSystem = localFs,
      httpActor = null,
      rootID = root,
      transform = filterTempPaths(generator)
    )

    given typed.ActorSystem[_] = context.system.toTyped

    val source = Walk.dfsSource(walkOptions)
      .map(processElement)
      .filter(_.isDefined)
      .map(_.get)
    val sink = Sink.fold[List[Model.Folder[Path]], Model.Folder[Path]](List.empty) { (list, folder) =>
      folder :: list
    }
    source.runWith(sink)

  /**
    * Filters out temporary paths to be deleted from the given list of
    * elements. This is used as transformation function for the walk operation
    * over the temporary folder structure.
    *
    * @param generator the path generator
    * @param elements  the elements to filter
    * @return the filtered list of elements
    */
  private def filterTempPaths(generator: TempPathGenerator)
                             (elements: List[Model.Element[Path]]): List[Model.Element[Path]] =
    elements.filter(elem => generator.isRemovableTempPath(elem.id))

  /**
    * Processes a single element during the iteration over the temporary root
    * directory. If the element is a file, it is deleted. Otherwise, it is
    * returned as a folder for later removal.
    *
    * @param elem the element to process
    * @return an [[Option]] with the folder to collect
    */
  private def processElement(elem: Model.Element[Path]): Option[Model.Folder[Path]] =
    elem match
      case file: Model.File[Path] =>
        deleteElement(file)
        None
      case folder: Model.Folder[Path] =>
        Some(folder)

  /**
    * Deletes the given element using the remove file actor.
    *
    * @param elem the element to be deleted
    */
  private def deleteElement(elem: Model.Element[Path]): Unit =
    removeFileActor ! RemoveFileActor.RemoveFile(elem.id)
