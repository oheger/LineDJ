/*
 * Copyright 2015-2017 The Developers Team.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.oliver_heger.linedj.archive.media

import java.nio.file.Path

import de.oliver_heger.linedj.io.FileData
import de.oliver_heger.linedj.shared.archive.media.MediumID

object MediaFileUriHandler {
  /**
    * A prefix for media file URIs that represent song files located under a
    * medium root.
    */
  val PrefixPath = "path://"

  /**
    * A prefix for the URIs of media files in the global list of undefined
    * media. Such URIs actually reference files located on other media.
    */
  val PrefixReference = "ref://"

  /**
    * Constant for a path URI prefix which is used when the URI is embedded
    * into a reference URI.
    */
  private val PathSeparator = ":" + PrefixPath

  /**
    * Extracts the part of a reference URI which defines the URI of the
    * referenced medium.
    *
    * @param refUri the reference URI
    * @return an option with the URI of the referenced medium
    */
  private def extractMediumUriFromRefUri(refUri: String): Option[String] = {
    val index = refUri indexOf PathSeparator
    if (index > 0) Some(refUri.substring(PrefixReference.length, index))
    else None
  }
}

/**
  * A class which is responsible for the handling of the URIs for media files.
  *
  * On the server side, media files are accessed directly by using their
  * absolute ''Path'' objects. When information about media files is passed to
  * the client these paths are converted to URIs. Clients request media files
  * in terms of their URIs; so there has to be a bidirectional conversion
  * between paths and URIs. This class is responsible for this.
  *
  * Situation is a bit more complicated because of the global list of files
  * that do not belong to a medium. The URIs for the files in this list need to
  * have a special format, so that they can be mapped again to paths objects.
  */
class MediaFileUriHandler {

  import MediaFileUriHandler._

  /**
    * Generates the URI for a regular medium file that is located under a
    * specific medium root.
    *
    * @param mediumRoot the root path for the medium
    * @param path       the path to the file in question
    * @return the generated URI for this file
    */
  def generateMediaFileUri(mediumRoot: Path, path: Path): String =
    PrefixPath + mediumRoot.relativize(path).toString.replace('\\', '/')

  /**
    * Generates a URI to be used for the global undefined medium list that
    * references a file on another medium. The passed in URI must be a valid
    * URI as generated by ''generateMediumFileUri()''. It is transformed in a
    * way so that it can later be parsed again to a path by referencing the
    * medium the file belongs to.
    *
    * @param mediumID the URI of the owning medium
    * @param pathURI  the URI in terms of the owning medium
    * @return the generated URI referencing this file
    */
  def generateUndefinedMediumUri(mediumID: MediumID, pathURI: String): String =
    PrefixReference + mediumID.mediumURI + ":" + pathURI

  /**
    * Removes the prefix (indicating the URI type) from the given URI. This is
    * useful for instance if only the relative URI is of interest, e.g. for
    * checksum calculation.
    *
    * @param uri the URI
    * @return the URI with the removed prefix
    */
  def removePrefix(uri: String): String =
    if (uri startsWith PrefixPath) uri.substring(PrefixPath.length)
    else if (uri startsWith PrefixReference) uri.substring(PrefixReference.length)
    else uri

  /**
    * Resolves the URI to a medium file. This method can handle URIs produced
    * by the ''generate()'' methods. It is able to retrieve the corresponding
    * ''FileData'' object by looking up the URI in a mapping table. The mapping
    * table contains all known medium IDs and a URI to path mapping for each.
    *
    * @param mediumID  the ID of the owning medium
    * @param uri       the URI to be resolved
    * @param mediaData the mapping for known media and their files
    * @return an option with the resolved ''FileData'' object
    */
  def resolveUri(mediumID: MediumID, uri: String, mediaData: scala.collection.mutable
  .Map[MediumID, Map[String,
    FileData]]): Option[FileData] = {
    if (uri startsWith PrefixReference) {
      resolveReferenceUri(uri, mediaData)
    } else {
      resolvePathUri(mediumID, uri, mediaData)
    }
  }

  /**
    * Resolves a URI pointing to a file in the global undefined medium list. In
    * this case the actual target medium and the path URI are extracted from
    * the reference URI.
    *
    * @param uri       the URI to be resolved
    * @param mediaData the mapping for known media and their files
    * @return an option with the resolved ''FileData'' object
    */
  private def resolveReferenceUri(uri: String, mediaData: scala.collection.mutable.Map[MediumID,
    Map[String, FileData]]):
  Option[FileData] =
    for {
      mediumUri <- extractMediumUriFromRefUri(uri)
      referencedMedium <- mediaData.keys.find(_.mediumURI == mediumUri)
      data <- resolvePathUri(referencedMedium, uri.substring(PrefixReference.length +
        referencedMedium.mediumURI.length + 1), mediaData)
    } yield data

  /**
    * Resolves a URI pointing to a file belonging to a defined medium. In this
    * case, the ''FileData'' can be obtained from the URI mapping.
    *
    * @param mediumID  the ID of the owning medium
    * @param uri       the URI to be resolved
    * @param mediaData the mapping for known media and their files
    * @return an option with the resolved ''FileData'' object
    */
  private def resolvePathUri(mediumID: MediumID, uri: String, mediaData: scala.collection.mutable
  .Map[MediumID, Map[String, FileData]]): Option[FileData] =
    mediaData.get(mediumID).flatMap(_.get(uri))
}
