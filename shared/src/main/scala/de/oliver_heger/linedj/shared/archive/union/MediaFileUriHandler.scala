/*
 * Copyright 2015-2017 The Developers Team.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.oliver_heger.linedj.shared.archive.union

import java.net.{URLDecoder, URLEncoder}
import java.nio.charset.StandardCharsets
import java.nio.file.Path
import java.util.regex.Pattern

import de.oliver_heger.linedj.io.FileData
import de.oliver_heger.linedj.shared.archive.media.MediumID

import scala.collection.mutable

/**
  * A data class representing an URI for the global undefined medium split
  * into its single components.
  * @param mediumURI the URI of the medium
  * @param componentID the ID of the archive component responsible for the
  *                    represented file
  * @param path the path local to the archive component (without the path
  *             prefix)
  */
case class UndefinedMediumUri(mediumURI: String, componentID: String, path: String) {
  /**
    * The URI to the referenced file, local to the archive component. This is
    * the ''path'' prefixed with the ''PathPrefix''
    */
  lazy val pathUri: String = MediaFileUriHandler.PrefixPath + path
}

/**
  * A class which is responsible for the handling of the URIs for media files.
  *
  * An archive component typically accesses media files directly by using their
  * absolute ''Path'' objects. When information about media files is passed to
  * clients these paths are converted to URIs. Clients request media files
  * in terms of their URIs; so there has to be a bidirectional conversion
  * between paths and URIs. This class is responsible for this.
  *
  * Situation is a bit more complicated because of the global list of files
  * that do not belong to a medium. The URIs for the files in this list need to
  * have a special format, so that they can be mapped again to paths objects,
  * also identifying the owning archive component.
  */
object MediaFileUriHandler {
  /**
    * A prefix for media file URIs that represent song files located under a
    * medium root.
    */
  val PrefixPath = "path://"

  /**
    * A prefix for the URIs of media files in the global list of undefined
    * media. Such URIs actually reference files located on other media.
    */
  val PrefixReference = "ref://"

  /** Regular expression for parsing undefined medium URIs. */
  private val RegExUndefinedMediumUri = (Pattern.quote(PrefixReference) +
    """(.+):(.*):""" + Pattern.quote(PrefixPath) + "(.+)").r

  /** Constant for the separator character in URIs. */
  private val UriSeparator = ":"

  /**
    * Generates the URI for a regular medium file that is located under a
    * specific medium root.
    *
    * @param mediumRoot the root path for the medium
    * @param path       the path to the file in question
    * @return the generated URI for this file
    */
  def generateMediaFileUri(mediumRoot: Path, path: Path): String =
    PrefixPath + mediumRoot.relativize(path).toString.replace('\\', '/')

  /**
    * Generates a URI to be used for the global undefined medium list that
    * references a file on another medium. The passed in URI must be a valid
    * URI as generated by ''generateMediumFileUri()''. It is transformed in a
    * way so that it can later be parsed again to a path by referencing the
    * medium the file belongs to.
    *
    * @param mediumID the URI of the owning medium
    * @param pathURI  the URI in terms of the owning medium
    * @return the generated URI referencing this file
    */
  def generateUndefinedMediumUri(mediumID: MediumID, pathURI: String): String =
    PrefixReference + encodeMediumID(mediumID) + UriSeparator + pathURI

  /**
    * Removes the prefix (indicating the URI type) from the given URI. This is
    * useful for instance if only the relative URI is of interest, e.g. for
    * checksum calculation.
    *
    * @param uri the URI
    * @return the URI with the removed prefix
    */
  def removePrefix(uri: String): String =
    if (uri startsWith PrefixPath) uri.substring(PrefixPath.length)
    else if (uri startsWith PrefixReference) uri.substring(PrefixReference.length)
    else uri

  /**
    * Extracts the single components of an URI pointing the global undefined
    * medium. If the URI is valid, an ''UndefinedMediumUri'' object is returned
    * allowing direct access to the single URI components. Otherwise, result is
    * ''None''.
    *
    * @param refUri the reference URI to be extracted
    * @return an option with the ''UndefinedMediumUri'' object extracted
    */
  def extractRefUri(refUri: String): Option[UndefinedMediumUri] =
    refUri match {
      case RegExUndefinedMediumUri(medUri, compID, path) =>
        Some(UndefinedMediumUri(medUri, decodeComponentID(compID), path))
      case _ => None
    }

  /**
    * Resolves the URI to a medium file. This method can handle URIs produced
    * by the ''generate()'' methods. It is able to retrieve the corresponding
    * ''FileData'' object by looking up the URI in a mapping table. The mapping
    * table contains all known medium IDs and a URI to path mapping for each.
    *
    * @param mediumID  the ID of the owning medium
    * @param uri       the URI to be resolved
    * @param mediaData the mapping for known media and their files
    * @return an option with the resolved ''FileData'' object
    */
  def resolveUri(mediumID: MediumID, uri: String, mediaData: scala.collection.mutable
  .Map[MediumID, Map[String, FileData]]): Option[FileData] = {
    if (uri startsWith PrefixReference) {
      resolveReferenceUri(uri, mediaData)
    } else {
      resolvePathUri(mediumID, uri, mediaData)
    }
  }

  /**
    * Resolves a URI pointing to a file in the global undefined medium list. In
    * this case the actual target medium and the path URI are extracted from
    * the reference URI.
    *
    * @param uri       the URI to be resolved
    * @param mediaData the mapping for known media and their files
    * @return an option with the resolved ''FileData'' object
    */
  private def resolveReferenceUri(uri: String, mediaData: scala.collection.mutable.Map[MediumID,
    Map[String, FileData]]): Option[FileData] =
    for {
      extractedUri <- extractRefUri(uri)
      referencedMedium <- findMediumForUri(mediaData, extractedUri)
      data <- resolvePathUri(referencedMedium, extractedUri.pathUri, mediaData)
    } yield data

  /**
    * Tries to match the medium ID for the specified ''UndefinedMediumUri''.
    *
    * @param mediaData    the map with data about available media
    * @param undefinedUri the ''UndefinedMediumUri''
    * @return an option with the matched ''MediumID''
    */
  private def findMediumForUri(mediaData: mutable.Map[MediumID, Map[String, FileData]],
                               undefinedUri: UndefinedMediumUri): Option[MediumID] =
    mediaData.keys.find { m =>
      m.mediumURI == undefinedUri.mediumURI &&
        m.archiveComponentID == undefinedUri.componentID
    }

  /**
    * Returns an encoded form of the specified medium ID. For URIs of the
    * global undefined medium the original medium ID has to be contained in
    * encoded form.
    *
    * @param mid the ''MediumID'' to be encoded
    * @return the encoded ''MediumID''
    */
  private def encodeMediumID(mid: MediumID): String =
    mid.mediumURI + UriSeparator + encodeComponentID(mid.archiveComponentID)

  /**
    * Resolves a URI pointing to a file belonging to a defined medium. In this
    * case, the ''FileData'' can be obtained from the URI mapping.
    *
    * @param mediumID  the ID of the owning medium
    * @param uri       the URI to be resolved
    * @param mediaData the mapping for known media and their files
    * @return an option with the resolved ''FileData'' object
    */
  private def resolvePathUri(mediumID: MediumID, uri: String, mediaData: scala.collection.mutable
  .Map[MediumID, Map[String, FileData]]): Option[FileData] =
    mediaData.get(mediumID).flatMap(_.get(uri))

  /**
    * Encodes an archive component ID so that it can be referenced in a URI.
    *
    * @param compID the component ID to be encoded
    * @return the encoded component ID
    */
  private def encodeComponentID(compID: String): String =
    URLEncoder.encode(compID, StandardCharsets.UTF_8.name())

  /**
    * Decodes an archive component ID extracted from a URI.
    *
    * @param compID the encoded component ID
    * @return the decoded component ID
    */
  private def decodeComponentID(compID: String): String =
    URLDecoder.decode(compID, StandardCharsets.UTF_8.name())
}
